# Spring

## Жизненный цикл бинов
1. Парсирование конфигурации и создание BeanDefinition. BeanDefinitionReader отвечает за считывание конфигураций.
2. Настройка BeanDefinitions при помощи BeanPostProcessor.
Интерфейс BeanPostProcessor с единственным методом postProcessBeanFactory позволяет настраивать бины до того, как они
попадут в IOC контейнер. Понадобится эта функция может в случаях, когда для изменяемый бин требуется для создания других бинов.
Например, когда нужно создать кастомную аннотацию. Также можно использовать BeanPostProcessor для чтения property-файлов и получения из них свойства бинов.
3. Создание бинов и перемещение их в контейнерю BeanDefinitions при этом представляют собой Map, в которой в качестве ключа выступает id бина, а в качестве
значения - его декларация. К декларации бина относится:
- Имя класса с пакетом.
- Имя бина, destroy, init-методы.
- Желаемое поведение (scope, обратные вызовы жизненного цикла и т.д.)ю
- Зависимости (ссылки на другие бины).

## Как разрешить циклические зависимости
Циклическая зависимость - когда бин А зависит от бина Б, но бин Б в то же
время зависит от бита А. Спринг не может решить, какой бин создавать первым 
и выбрасывает _BeanCurrentlyInCreationException_.
Способы решения:
- Сделать рефакторинг: обязанности должны быть четко разделены, а иерархия соблюдаться. 
- Использовать @Lazy для одного из компонентов. Тогда, вместо полной инициализации,
Spring создаст прокси, чтобы заинжектить его в другой класс. И бин будет создан в первый раз
только тогда, когда понадобится.
- Использовать для внедрения зависимости сеттеры или поля вместо конструкторов. В этом случае
зависимости будут созданы по мере необходимости.
- Использовать @PostConstruct. 

## Особенности бинов со scope prototype и singltone
- Бин с областью Singleton создается сразу после поднятия контекста. Prototype создается в момент, когда он нужен, и не хранится в IOC
контейнере. Соответственно и метод destroy у него будет вызвать нельзя. 
- Singltone - потокобезопасный, так кк гарантирует что один и тот же экземпляр будет вызываться только в 1 потоке. Бины со scope prorotype 
в многопоточности лучше не использовать. 

